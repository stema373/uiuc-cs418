<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <link rel="icon" href="data:,">
  <title>Subdivison Surface</title>
  <script src="wrapWebGL2.js"></script>
  <script src="math.js"></script>
  <script>
let objData = {
  levels: [],
  currentLevel: 0,
  positionBuffer: null,
  numVertices: 0,
}
let program = null

/**
 * Half-edge mesh representation using parallel arrays
 */
function buildHalfEdgeFromOBJ(positions, faces) {
  const mesh = {
    verts: positions.map(p => p.slice()),
    heV: [],
    heNext: [],
    heTwin: [],
    heFace: [],
    faces: []
  }

  const edgeMap = new Map()

  for (let f = 0; f < faces.length; f++) {
    const face = faces[f]
    if (face.length < 3) continue
    const startHe = mesh.heV.length 
    mesh.faces.push(startHe)

    const n = face.length 
    for (let i = 0; i < n; i++) {
      const heIndex = mesh.heV.length 
      mesh.heV.push(face[i])
      mesh.heNext.push(heIndex + 1)
      mesh.heTwin.push(-1)
      mesh.heFace.push(f)

      const a = face[i]
      const b = face[(i + 1) % n]
      edgeMap.set(`${a}->${b}`, heIndex)
    }
    mesh.heNext[startHe + n - 1] = startHe
  }

  for (const key of edgeMap.keys()) {
    const [aStr, bStr] = key.split('->')
    const a = parseInt(aStr), b = parseInt(bStr)
    const revKey = `${b}->${a}`
    const he = edgeMap.get(key)
    if (edgeMap.has(revKey)) {
      const heTwin = edgeMap.get(revKey)
      mesh.heTwin[he] = heTwin
    } else {
      mesh.heTwin[he] = -1
    }
  }

  return mesh
}

function computeFaceNormal(mesh, faceIndex) {
  const heStart = mesh.faces[faceIndex]
  const v0 = mesh.heV[heStart]
  const v1 = mesh.heV[mesh.heNext[heStart]]
  const he2 = mesh.heNext[mesh.heNext[heStart]]
  const v2 = mesh.heV[he2]
  const p0 = mesh.verts[v0]
  const p1 = mesh.verts[v1]
  const p2 = mesh.verts[v2]
  return normalize(cross(sub(p1, p0), sub(p2, p0)))
}

function buildRenderBuffers(mesh) {
  const positions = []
  const normals = []
  const stride = 6 

  for (let f = 0; f < mesh.faces.length; f++) {
    const heStart = mesh.faces[f]
    const verts = []
    for (let he = heStart; ; he = mesh.heNext[he]) {
      verts.push(mesh.heV[he])
      if (mesh.heNext[he] === heStart) break
    }
    const faceNormal = computeFaceNormal(mesh, f)
    for (let i = 1; i < verts.length - 1; i++) {
      const vi0 = verts[0]
      const vi1 = verts[i]
      const vi2 = verts[i + 1]
      const p0 = mesh.verts[vi0]
      const p1 = mesh.verts[vi1]
      const p2 = mesh.verts[vi2]
      positions.push(...p0)
      positions.push(...p1)
      positions.push(...p2)
      normals.push(...faceNormal)
      normals.push(...faceNormal)
      normals.push(...faceNormal)
    }
  }

  objData.positionBuffer = gl.createBuffer()
  gl.bindBuffer(gl.ARRAY_BUFFER, objData.positionBuffer)
  const interleaved = new Float32Array((positions.length / 3) * stride)
  const vertCount = positions.length / 3 
  for (let i = 0; i < vertCount; i++) {
    interleaved[i * stride + 0] = positions[i * 3 + 0]
    interleaved[i * stride + 1] = positions[i * 3 + 1]
    interleaved[i * stride + 2] = positions[i * 3 + 2]
    interleaved[i * stride + 3] = normals[i * 3 + 0]
    interleaved[i * stride + 4] = normals[i * 3 + 1]
    interleaved[i * stride + 5] = normals[i * 3 + 2]
  }
  gl.bufferData(gl.ARRAY_BUFFER, interleaved, gl.STATIC_DRAW)

  objData.numVertices = vertCount
}

/**
 * Catmull-Clark subdivision using half-edge mesh.
 */ 
function catmullClark(mesh) {
  const facePoints = Array(mesh.faces.length)
  for (let f = 0; f < mesh.faces.length; f++) {
    const heStart = mesh.faces[f]
    const pts = []
    for (let he = heStart; ; he = mesh.heNext[he]) {
      pts.push(mesh.verts[mesh.heV[he]])
      if (mesh.heNext[he] === heStart) break
    }
    const avg = [0, 0, 0]
    for (const p of pts) {
      avg[0] += p[0]
      avg[1] += p[1]
      avg[2] += p[2]
    }
    avg[0] /= pts.length
    avg[1] /= pts.length
    avg[2] /= pts.length
    facePoints[f] = avg
  }

  const edgeKey = (a, b) => a < b ? `${a}_${b}` : `${b}_${a}`
  const edgeInfo = new Map()
  for (let he = 0; he < mesh.heV.length; he++) {
    const a = mesh.heV[he]
    const b = mesh.heV[mesh.heNext[he]]
    const key = edgeKey(a, b)
    if (!edgeInfo.has(key)) {
      edgeInfo.set(key, {a, b, hes: [], faces: []})
    }
    const info = edgeInfo.get(key)
    info.hes.push(he)
    info.faces.push(mesh.heFace[he])
  }

  const edgePoints = new Map()
  for (const [key, info] of edgeInfo.entries()) {
    const pa = mesh.verts[info.a]
    const pb = mesh.verts[info.b]
    let ep = [ (pa[0] + pb[0]) / 2, (pa[1] + pb[1]) / 2, (pa[2] + pb[2]) / 2 ]
    if (info.faces.length === 2) {
      const f1 = facePoints[info.faces[0]]
      const f2 = facePoints[info.faces[1]]
      ep = [ (pa[0] + pb[0] + f1[0] + f2[0]) / 4,
             (pa[1] + pb[1] + f1[1] + f2[1]) / 4,
             (pa[2] + pb[2] + f1[2] + f2[2]) / 4 ]
    } else if (info.faces.length === 1) {
      const f1 = facePoints[info.faces[0]]
      ep = [ (pa[0] + pb[0] + 2 * f1[0]) / 4,
             (pa[1] + pb[1] + 2 * f1[1]) / 4,
             (pa[2] + pb[2] + 2 * f1[2]) / 4 ]
    }
    edgePoints.set(key, ep)
  }

  const newVerts = Array(mesh.verts.length)
  for (let vi = 0; vi < mesh.verts.length; vi++) {
    let heStart = -1 
    for (let he = 0; he < mesh.heV.length; he++) {
      if (mesh.heV[he] === vi) {
        heStart = he 
        break
      }
    }
    if (heStart === -1) {
      newVerts[vi] = mesh.verts[vi].slice()
      continue
    }
    const facesAdj = []
    const neigh = []
    for (let he = heStart; ; ) {
      const vNext = mesh.heV[mesh.heNext[he]]
      neigh.push(mesh.verts[vNext])
      facesAdj.push(facePoints[mesh.heFace[he]])
      const twin = mesh.heTwin[he]
      if (twin === -1) break 
      he = mesh.heNext[twin]
      if (he === heStart) break 
    }
    const n = neigh.length 
    const Q = [0, 0, 0]
    for (const f of facesAdj) {
      Q[0] += f[0]
      Q[1] += f[1]
      Q[2] += f[2]
    }
    Q[0] /= n 
    Q[1] /= n 
    Q[2] /= n
    const R = [0, 0, 0]
    for (const nv of neigh) {
      R[0] += (mesh.verts[vi][0] + nv[0]) / 2 
      R[1] += (mesh.verts[vi][1] + nv[1]) / 2 
      R[2] += (mesh.verts[vi][2] + nv[2]) / 2
    }
    R[0] /= n 
    R[1] /= n 
    R[2] /= n
    const P = mesh.verts[vi]
    newVerts[vi] = [ (Q[0] + 2 * R[0] + (n - 3) * P[0]) / n,
                     (Q[1] + 2 * R[1] + (n - 3) * P[1]) / n,
                     (Q[2] + 2 * R[2] + (n - 3) * P[2]) / n ]
  }

  const newFaces = []
  for (let f = 0; f < mesh.faces.length; f++) {
    const heStart = mesh.faces[f]
    const verts = []
    for (let he = heStart; ; he = mesh.heNext[he]) {
      verts.push(mesh.heV[he])
      if (mesh.heNext[he] === heStart) break
    }
    const n = verts.length 
    for (let i = 0; i < n; i++) {
      const vi = verts[i]
      const vj = verts[(i + 1) % n]
      const vk = verts[(i - 1 + n) % n]
      const keyForward = vi < vj ? `${vi}_${vj}` : `${vj}_${vi}`
      const keyBack = vk < vi ? `${vk}_${vi}` : `${vi}_${vk}`
      const ep1 = edgePoints.get(keyForward)
      const ep2 = edgePoints.get(keyBack)
      const fp = facePoints[f]
      newFaces.push([ newVerts[vi], ep1, fp, ep2 ])
    }
  }

  const vmap = new Map()
  const newPositions = []
  const newFacesIndices = []
  function keyFromPos(p) {
    return `${p[0].toFixed(8)}_${p[1].toFixed(8)}_${p[2].toFixed(8)}`
  }
  for (const face of newFaces) {
    const inds = []
    for (const p of face) {
      const k = keyFromPos(p)
      if (!vmap.has(k)) {
        vmap.set(k, newPositions.length)
        newPositions.push(p.slice())
      }
      inds.push(vmap.get(k))
    }
    newFacesIndices.push(inds)
  }

  const newMesh = buildHalfEdgeFromOBJ(newPositions, newFacesIndices)
  return newMesh
}

/**
 * Parse OBJ file text into buffers
 */ 
async function loadOBJ(obj) {
  const lines = obj.split('\n')

  const positions = []
  const texcoords = []
  const normals = []
  const facesRaw = []

  for (let line of lines) {
    line = line.trim()
    if (line.length === 0 || line.startsWith('#')) continue
    if (line.startsWith('v ')) {
      const parts = line.split(/\s+/).slice(1).map(Number)
      positions.push([parts[0], parts[1], parts[2]])
    } else if (line.startsWith('vt ')) {
      const [, u, v] = line.split(/\s+/)
      texcoords.push([parseFloat(u), parseFloat(v)])
    } else if (line.startsWith('vn ')) {
      const [, x, y, z] = line.split(/\s+/)
      normals.push([parseFloat(x), parseFloat(y), parseFloat(z)])
    } else if (line.startsWith('f ')) {
      const [, ...verts] = line.split(/\s+/)
      const face = verts.map(v => {
        const parts = v.split('/')
        const vi = parseInt(parts[0])
        const idx = (vi > 0) ? (vi - 1) : (positions.length + vi)
        return idx
      })
      facesRaw.push(face)
    }
  }

  // Orient OBJ 
  for (let i = 0; i < positions.length; i++) {
    const [x, y, z] = positions[i]
    positions[i] = [x, z, -y]
  }

  // Center and scale
  const xs = positions.map(p => p[0])
  const ys = positions.map(p => p[1])
  const zs = positions.map(p => p[2])
  const min = [Math.min(...xs), Math.min(...ys), Math.min(...zs)]
  const max = [Math.max(...xs), Math.max(...ys), Math.max(...zs)]
  const center = [(min[0] + max[0]) / 2, (min[1] + max[1]) / 2, (min[2] + max[2]) / 2]
  const maxExtent = Math.max(max[0] - min[0], max[1] - min[1], max[2] - min[2])
  const scale = 1.5 / maxExtent
  for (let i = 0; i < positions.length; i++) {
    positions[i][0] = (positions[i][0] - center[0]) * scale
    positions[i][1] = (positions[i][1] - center[1]) * scale
    positions[i][2] = (positions[i][2] - center[2]) * scale
  }

  const mesh0 = buildHalfEdgeFromOBJ(positions, facesRaw)

  objData.levels = [mesh0]
  objData.currentLevel = 0

  buildRenderBuffers(mesh0)
}

/**
 * Compiles two shaders, links them together, looks up their uniform locations,
 * and returns the result. Reports any shader errors to the console.
 *
 * @param {string} vs_source - the source code of the vertex shader 
 * @param {string} fs_source - the source code of the fragment shader 
 * @return{WebGLProgram} the compiled and linked program
*/
function compile(vs_source, fs_source) {
  const vs = gl.createShader(gl.VERTEX_SHADER)
  gl.shaderSource(vs, vs_source)
  gl.compileShader(vs)
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(vs))
    throw Error("Vertex shader compilation failed")
  }

  const fs = gl.createShader(gl.FRAGMENT_SHADER)
  gl.shaderSource(fs, fs_source)
  gl.compileShader(fs)
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(fs))
    throw Error("Fragment shader compilation failed")
  }

  const program = gl.createProgram()
  gl.attachShader(program, vs)
  gl.attachShader(program, fs)
  gl.linkProgram(program)
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program))
    throw Error("Linking failed")
  }

  const uniforms = {}
  for (let i=0; i<gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); i+=1) {
    let info = gl.getActiveUniform(program, i)
    uniforms[info.name] = gl.getUniformLocation(program, info.name)
  }
  program.uniforms = uniforms

  return program
}

/**
 * Setup WebGL
 */
async function setup() {
  const canvas = document.querySelector('canvas')
  gl = canvas.getContext('webgl2')

  gl.enable(gl.DEPTH_TEST)

  const vs = await fetch('vs.glsl').then(res => res.text())
  const fs = await fetch('fs.glsl').then(res => res.text())
  program = compile(vs, fs)

  fillScreen()
  window.addEventListener('resize', fillScreen)

  document.getElementById('file').addEventListener('change', async event => {
    if (event.target.files.length != 1) {
      console.debug("No file selected")
      return
    }
    const txt = await event.target.files[0].text()
    if (!/^v .*^v .*^v .*^f /gms.test(txt)) {
      console.debug("File not a valid OBJ file")
      return
    }

    await loadOBJ(txt)
  })
  document.getElementById('levels').addEventListener('change', async event => {
    const level = Math.min(document.getElementById('levels').value, 5) | 0 

    while(objData.levels.length <= level) {
      const prev = objData.levels[objData.levels.length - 1]
      const next = catmullClark(prev)
      objData.levels.push(next)
    }
    objData.currentLevel = level 
    buildRenderBuffers(objData.levels[level])
  })

  tick(0)
}

/**
 * Resize canvas to fill screen 
 */
function fillScreen() {
  let canvas = document.querySelector('canvas')
  document.body.style.margin = '0'
  canvas.style.width = '100%'
  canvas.style.height = '100%'
  canvas.width = canvas.clientWidth
  canvas.height = canvas.clientHeight
  canvas.style.width = ''
  canvas.style.height = ''
  gl.viewport(0,0, canvas.width, canvas.height)
}

/**
 * Runs the animation using requestAnimationFrame. This is like a loop that
 * runs once per screen refresh, but a loop won't work because we need to let 
 * the browser do other things between ticks. Instead, we have a function that 
 * requests itself be queued to be run again as its last step.
 *
 * @param {Number} milliseconds - milliseconds since web page loaded;
 *        automatically provided by the browser when invoked with 
 *        requestAnimationFrame
 */
function tick(milliseconds) {
  const seconds = milliseconds / 1000
  draw(seconds)
  requestAnimationFrame(tick) // <- only call this here, nowhere else
}

/**
 * Draw frame 
 */
function draw(seconds) {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

  if (!objData || !objData.positionBuffer) return

  gl.useProgram(program)

  const radius = 2.5 
  const cameraHeight = 1.5 
  const cameraX = radius * Math.cos(seconds * 0.3)
  const cameraZ = radius * Math.sin(seconds * 0.3)
  const eye = [cameraX, cameraHeight, cameraZ]
  const center = [0, 0, 0]
  const up = [0, 1, 0]

  const viewMatrix = m4view(eye, center, up)

  const canvas = document.querySelector('canvas')
  const projMatrix = m4perspNegZ(0.1, 100, Math.PI / 3, canvas.width, canvas.height)
  
  const lightDir = [1, 2, 1]
  const lightDirNorm = normalize(lightDir)

  const mvLoc = gl.getUniformLocation(program, 'mv')
  const pLoc = gl.getUniformLocation(program, 'p')
  const lightDirLoc = gl.getUniformLocation(program, 'lightDirection')

  gl.uniformMatrix4fv(mvLoc, false, viewMatrix)
  gl.uniformMatrix4fv(pLoc, false, projMatrix)
  gl.uniform3fv(lightDirLoc, lightDirNorm)

  const eyePosLoc = gl.getUniformLocation(program, 'eyePosition')
  gl.uniform3fv(eyePosLoc, eye)

  gl.bindBuffer(gl.ARRAY_BUFFER, objData.positionBuffer)
  const strideBytes = 6 * 4
  gl.enableVertexAttribArray(0)
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, strideBytes, 0)
  gl.enableVertexAttribArray(1)
  gl.vertexAttribPointer(1, 3, gl.FLOAT, false, strideBytes, 3 * 4)

  gl.drawArrays(gl.TRIANGLES, 0, objData.numVertices)
}

window.addEventListener('load', setup)

  </script>
    <style>
    body {
        margin: 0; border: none; padding: 0;
        display: flex; flex-direction: column;
        width: 100%; height: 100vh;
    }
    .controls {
        flex: 0 0 auto;
    }
    .controls > * { margin: 1em; }
    .display {
        flex-grow: 1;
        line-height: 0rem;
    }
    </style>
</head>
<body>
<label>OBJ File path: <input id="file" type="file"/></label>
<label>Levels: <input id="levels" type="number" value="0" max="5" min="0" step="1"/></label>
<canvas></canvas>
</body>
</html>
