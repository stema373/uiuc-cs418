<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <link rel="icon" href="data:,">
  <title>Parametric Geometry</title>
  <script src="wrapWebGL2.js"></script>
  <script src="math.js"></script>
  <script>
let meshData= null 

/**
 * Helper Matrix function 
 */ 
function vec3Normalize(v) {
  const len = Math.hypot(v[0], v[1], v[2])
  return [v[0] / len, v[1] / len, v[2] / len]
}

/**
 * Generate a sphere with latitude/longitude grid 
 */ 
function generateSphere(rings, slices) {
  const vertices = []
  const normals = []
  const indices = []

  vertices.push(0, 1, 0)
  normals.push(0, 1, 0)

  for (let r = 0; r < rings; r++) {
    const theta = Math.PI * (r + 1) / (rings + 1)
    const sinTheta = Math.sin(theta)
    const cosTheta = Math.cos(theta)

    for (let s = 0; s < slices; s++) {
      const phi = 2 * Math.PI * s / slices 
      const sinPhi = Math.sin(phi)
      const cosPhi = Math.cos(phi)

      const x = sinTheta * cosPhi 
      const y = cosTheta 
      const z = sinTheta * sinPhi 

      vertices.push(x, y, z)
      normals.push(x, y, z)
    }
  }

  vertices.push(0, -1, 0)
  normals.push(0, -1, 0)

  for (let s = 0; s < slices; s++) {
    const next = (s + 1) % slices 
    indices.push(0, s + 1, next + 1)
  }

  for (let r = 0; r < rings - 1; r++) {
    for (let s = 0; s < slices; s++) {
      const current = 1 + r * slices + s 
      const next = 1 + r * slices + (s + 1) % slices 
      const below = 1 + (r + 1) * slices + s 
      const belowNext = 1 + (r + 1) * slices + (s + 1) % slices 

      indices.push(current, below, next)
      indices.push(next, below, belowNext)
    }
  }

  const bottomPoleIdx = 1 + rings * slices 
  for (let s = 0; s < slices; s++) {
    const current = 1 + (rings - 1) * slices + s 
    const next = 1 + (rings - 1) * slices + (s + 1) % slices 
    indices.push(current, bottomPoleIdx, next)
  }

  return {
    vertices: new Float32Array(vertices),
    normals: new Float32Array(normals),
    indices: new Uint16Array(indices),
    numTriangles: indices.length / 3
  }
}

/**
 * Generate a torus with a grid pattern
 */ 
function generateTorus(rings, slices) {
  const vertices = []
  const normals = []
  const indices = []

  const majorRadius = 0.75
  const minorRadius = 0.25

  for (let r = 0; r < rings; r++) {
    const theta = 2 * Math.PI * r / rings 
    const cosTheta = Math.cos(theta)
    const sinTheta = Math.sin(theta)

    for (let s = 0; s < slices; s++) {
      const phi = 2 * Math.PI * s / slices 
      const cosPhi = Math.cos(phi)
      const sinPhi = Math.sin(phi)

      const x = (majorRadius + minorRadius * cosTheta) * cosPhi
      const y = minorRadius * sinTheta
      const z = (majorRadius + minorRadius * cosTheta) * sinPhi

      vertices.push(x, y, z)

      const nx = cosTheta * cosPhi
      const ny = sinTheta
      const nz = cosTheta * sinPhi

      normals.push(nx, ny, nz)
    }
  }

  for (let r = 0; r < rings; r++) {
    for (let s = 0; s < slices; s++) {
      const current = r * slices + s 
      const next = r * slices + (s + 1) % slices 
      const below = ((r + 1) % rings) * slices + s 
      const belowNext = ((r + 1) % rings) * slices + (s + 1) % slices

      indices.push(current, below, next)
      indices.push(next, below, belowNext)
    }
  }

  return {
    vertices: new Float32Array(vertices),
    normals: new Float32Array(normals),
    indices: new Uint16Array(indices),
    numTriangles: indices.length / 3
  }
}

/**
 * Setup WebGL buffers for mesh
 */
function setupMeshBuffers(mesh) {
  const positionBuffer = gl.createBuffer()
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
  gl.bufferData(gl.ARRAY_BUFFER, mesh.vertices, gl.STATIC_DRAW)

  const normalBuffer = gl.createBuffer()
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
  gl.bufferData(gl.ARRAY_BUFFER, mesh.normals, gl.STATIC_DRAW)

  const indexBuffer = gl.createBuffer()
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW)

  return {
    position: positionBuffer,
    normal: normalBuffer,
    index: indexBuffer,
    numTriangles: mesh.numTriangles
  }
}

/**
 * Compiles two shaders, links them together, looks up their uniform locations,
 * and returns the result. Reports any shader errors to the console.
 *
 * @param {string} vs_source - the source code of the vertex shader 
 * @param {string} fs_source - the source code of the fragment shader 
 * @return{WebGLProgram} the compiled and linked program
*/
function compile(vs_source, fs_source) {
  const vs = gl.createShader(gl.VERTEX_SHADER)
  gl.shaderSource(vs, vs_source)
  gl.compileShader(vs)
  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(vs))
    throw Error("Vertex shader compilation failed")
  }

  const fs = gl.createShader(gl.FRAGMENT_SHADER)
  gl.shaderSource(fs, fs_source)
  gl.compileShader(fs)
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(fs))
    throw Error("Fragment shader compilation failed")
  }

  const program = gl.createProgram()
  gl.attachShader(program, vs)
  gl.attachShader(program, fs)
  gl.linkProgram(program)
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program))
    throw Error("Linking failed")
  }

  const uniforms = {}
  for (let i=0; i<gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); i+=1) {
    let info = gl.getActiveUniform(program, i)
    uniforms[info.name] = gl.getUniformLocation(program, info.name)
  }
  program.uniforms = uniforms

  return program
}

/**
 * Setup WebGL
 */
async function setup() {
  const canvas = document.querySelector('canvas')
  gl = canvas.getContext('webgl2')

  gl.enable(gl.DEPTH_TEST)

  const vs = await fetch('vs.glsl').then(res => res.text())
  const fs = await fetch('fs.glsl').then(res => res.text())
  window.program = compile(vs,fs)

  fillScreen()
  window.addEventListener('resize', fillScreen)

  document.querySelector('#submit').addEventListener('click', event => {
    const rings = Number(document.querySelector('#rings').value) || 1 
    const slices = Number(document.querySelector('#slices').value) || 3 
    const isTorus = document.querySelector('#torus').checked

    let mesh
    if (isTorus) {
      const validRings = Math.max(3, rings)
      const validSlices = Math.max(3, slices)
      mesh = generateTorus(validRings, validSlices)
    } else {
      const validRings = Math.max(1, rings)
      const validSlices = Math.max(3, slices)
      mesh = generateSphere(validRings, validSlices)
    }

    meshData = setupMeshBuffers(mesh)
  })

  tick(0)
}

/**
 * Resize canvas to fill screen 
 */
function fillScreen() {
  let canvas = document.querySelector('canvas')
  document.body.style.margin = '0'
  canvas.style.width = '100%'
  canvas.style.height = '100%'
  canvas.width = canvas.clientWidth
  canvas.height = canvas.clientHeight
  canvas.style.width = ''
  canvas.style.height = ''
  gl.viewport(0,0, canvas.width, canvas.height)
}

/**
 * Runs the animation using requestAnimationFrame. This is like a loop that
 * runs once per screen refresh, but a loop won't work because we need to let 
 * the browser do other things between ticks. Instead, we have a function that 
 * requests itself be queued to be run again as its last step.
 *
 * @param {Number} milliseconds - milliseconds since web page loaded;
 *        automatically provided by the browser when invoked with 
 *        requestAnimationFrame
 */
function tick(milliseconds) {
  const seconds = milliseconds / 1000
  draw(seconds)
  requestAnimationFrame(tick) // <- only call this here, nowhere else
}

/**
 * Draw frame 
 */
function draw(seconds) {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

  if (!meshData) return

  gl.useProgram(program)

  const radius = 2.5 
  const cameraHeight = 1.0 
  const cameraX = radius * Math.cos(seconds * 0.3)
  const cameraZ = radius * Math.sin(seconds * 0.3)
  const eye = [cameraX, cameraHeight, cameraZ]
  const center = [0, 0, 0]
  const up = [0, 1, 0]

  const viewMatrix = m4view(eye, center, up)

  const canvas = document.querySelector('canvas')
  const projMatrix = m4perspNegZ(0.1, 100, Math.PI / 3, canvas.width, canvas.height)
  
  const lightDir = [1, 2, 1]
  const lightDirNorm = vec3Normalize(lightDir)

  const mvLoc = gl.getUniformLocation(program, 'mv')
  const pLoc = gl.getUniformLocation(program, 'p')
  const lightDirLoc = gl.getUniformLocation(program, 'lightDirection')
  const eyePosLoc = gl.getUniformLocation(program, 'eyePosition')

  gl.uniformMatrix4fv(mvLoc, false, viewMatrix)
  gl.uniformMatrix4fv(pLoc, false, projMatrix)
  gl.uniform3fv(lightDirLoc, lightDirNorm)
  gl.uniform3fv(eyePosLoc, eye)

  gl.bindBuffer(gl.ARRAY_BUFFER, meshData.position)
  gl.enableVertexAttribArray(0)
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0)

  gl.bindBuffer(gl.ARRAY_BUFFER, meshData.normal)
  gl.enableVertexAttribArray(1)
  gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0)

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, meshData.index)
  gl.drawElements(gl.TRIANGLES, meshData.numTriangles * 3, gl.UNSIGNED_SHORT, 0)
}

window.addEventListener('load', setup)

  </script>
    <style>
    body {
        margin: 0; border: none; padding: 0;
        display: flex; flex-direction: column;
        width: 100%; height: 100vh;
    }
    .controls {
        flex: 0 0 auto;
    }
    .controls > * { margin: 1em; }
    .display {
        flex-grow: 1;
        line-height: 0rem;
    }
    </style>
</head>
<body>
<form class="controls" action="javascript:void(0);">
    <label>Rings: <input id="rings" type="number" value="1"/></label>
    <label>Slices: <input id="slices" type="number" value="3"/></label>
    <label>Torus: <input id="torus" type="checkbox"/></label>
    <input id="submit" type="submit" value="Make Object"/>
</form>
<div class="display">
    <canvas width="300" height="300"></canvas>
</div>
</body>
</html>
